knitr::opts_chunk$set(echo = TRUE)
library(igraph)
# Calculate degrees
deg <- degree(g)
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
edges <- read.csv("/Users/log/Github/Spring2025Classes/social_networks/project4/lasftm_asia/lastfm_asia_edges.csv")
g <- graph_from_data_frame(edges, directed = FALSE)
num_nodes = vcount(g)
num_edges = ecount(g)
# Check strong connectivity
components <- components(g)
# Extract the vertices belonging to the largest strongly connected component
largest_comp_vertices <- V(g)[components$membership == which.max(components$csize)]
g_largest <- induced_subgraph(g, largest_comp_vertices)
# Calculate diameter and radius on the largest SCC
diameter_largest <- diameter(g_largest)
radius_largest <- radius(g_largest)
output <- paste(
"Graph Summary",
paste("Number of nodes:", num_nodes),
paste("Number of edges:", num_edges),
paste("Density:", round(edge_density(g), 6)),
paste(""),
"Connectivity:",
paste("Number of strongly connected components:", components$no),
paste("Size of largest strongly connected component:", max(components$csize)),
paste("fraction of elements belonging to the largest strong subcomponent: ", max(components$csize)/num_nodes),
"The graph IS strongly connected",
paste(""),
paste("Largest diameter:", diameter_largest),
paste("Largest radius:", radius_largest),
"-------------------------------------------------------------------",
sep = "\n"
)
cat(output)
# Calculate global clustering coefficient (transitivity)
global_clustering <- transitivity(g, type = "global")
# Calculate local clustering coefficients for each node
local_clustering <- transitivity(g, type = "local")
# Calculate average local clustering coefficient
avg_local_clustering <- mean(local_clustering, na.rm = TRUE)
# Add to your output
cat("\nClustering Coefficients:\n")
cat(paste("Global clustering coefficient (transitivity):", round(global_clustering, 6), "\n"))
cat(paste("Average local clustering coefficient:", round(avg_local_clustering, 6), "\n"))
# Calculate degrees
deg <- degree(g)
# Create plots
par(mfrow=c(1,1))  # Set up a 1x3 plotting area
# Plot total degree distribution
hist(deg,
breaks = 80,  # Increase the number of buckets/bins
main = "Total Degree Distribution",
xlab = "Degree",
col = "lightblue",
border = "white",
xlim = c(0, max(deg)-170))
# Calculate the adjacency matrix
adj_matrix <- as_adjacency_matrix(g, sparse = FALSE)
# Function to calculate cosine similarity between two vectors
cosine_similarity <- function(x, y) {
return(sum(x * y) / (sqrt(sum(x^2)) * sqrt(sum(y^2))))
}
# Initialize cosine similarity matrix
n <- nrow(adj_matrix)
cosine_sim_matrix <- matrix(0, n, n)
# Calculate cosine similarity for each pair of nodes
for (i in 1:n) {
for (j in 1:n) {
if (i == j) {
cosine_sim_matrix[i, j] <- 1  # Self-similarity is 1
} else {
cosine_sim_matrix[i, j] <- cosine_similarity(adj_matrix[i, ], adj_matrix[j, ])
}
}
}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE, dev = "png", dpi = 96)
library(igraph)
library(distances)  # Faster distance calculations
library(parallelDist)
library(smacof)
install.packages("magick")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE, dev = "png", dpi = 96)
library(igraph)
library(distances)  # Faster distance calculations
library(parallelDist)
library(smacof)
library(magick)
mds_result <- mds(d_euc, ndim = 2, type = "ratio")
